---
layout: post
title:  "动态规划的一些知识"
date:   2015-12-20 01:44:45
categories:  Data Structures And Algorithm
author : 自来也
---



###Fabonacci Sequence

在数学里面，Fabonacci数或者Fabonacci数列就是下面的整数序列

0,1,1,2,3,5,8,13,21,34

在序列中，除前两个数，其他数都是前两个数的和

在计算fab数列，如果直接定义以递归的方式计算，那么气时间复杂度为O(2^n)，这种复杂度不能忍受

###基本的DP例子

有N种个硬币，他们价值分别是{v1, v2, ... ,Vn}，找出最小用多少枚硬币能够凑成价值S(每种硬币都可以使用多次)，或者指出不能够凑成总价值S

设最小能用i枚硬币凑成价值S，S去除一枚银币后的总价值是S-Vx(1<=x<=n),在这些(S-Vx)中找到一个最小值，然后加一，就是要找的S，当然，在计算S时，所有的1-(S-1)都是已经计算过的了,



````c
int main(){
	int v[3] = {1, 3, 5};
	int s = 12;
	int S[s];
	int i,j;
	for(i=0; i<s; i++){
		S[i] = 12;
	}
	S[0] = 0;
	for(i=0; i<s; i++){
		for(j=0; j<3; j++){
			if(v[j] <= i && (S[i - v[j]] + 1) < S[i]) {
				S[i] = S[i - v[j]] + 1;
			}
		}
		printf("%d---%d\n", i, S[i]);
	}
}
````


###入门问题Longest Common Subsequence

通过这个问题，学习怎么从一个状态转移到下一个状态，这个较多递推关系。

问题是， 序列A[1], A[2], ... , A[N]， 找出最长的非减序列。

定义一个状态i，i是以A[i]结尾的最长非减序列，这个状态只关心这个序列的长度，定义`j<i`，只要解决了所有小于i的所有状态j(j<i)，找出i之前的一个状态j,使得A[j]<A[i]，i状态对应的最长非减序列就是i=j+1，就这样，直到找到N。

例如这个序列  5, 3, 4, 8, 6, 7:


|  i  	|   最长子序列长度 	|  依靠j算出的最长子序列  	|
|  ---	|	---				|	---						|
|	1	|	1				|	0						|
|	2	|	1				|	0						|
|	3	|	2				|	2						|
|	4	|	3				|	3						|
|	5	|	3				|	3						|
|	6	|	4				|	5						|

算出其最长非减序列为3

代码为下面

````c
int main() {
	int n = 6;
	int i,j;
	int sq[n] = {5, 3, 4, 8, 6, 7};
	int a[n + 1];
	for(i=0;i<n;i++){
		a[i] = 1;
	}
	
	for(i=0;i<n;i++){
		for(j=0;j<=i;j++){
			if(sq[i] > sq[j] && a[j] + 1 > a[i]){
				a[i] = a[j] + 1;
			}
		}
	}
	
	for(i=0;i<n;i++){
		printf("%d", a[i]);
	}
}
````


####苹果问题

在一个由N*M组成的表A中，每行每列的位置都放了一定数量的苹果，要求从这个表中的左上角出发，每次只能向下或者向右走一格，求最多能在经过的路径中拿到多少苹果？

这也是一个动态规划的问题，每走的一步都依赖于上一步，上一步可以从上面来，也可以从左边来。先定义状态---“走到表中i,j位置时，经过路径能拿到最多的苹果”，然后再第k步的状态就是，K=Max(上面格子的状态，左边格子的状态)。

伪代码

````c

for(i=0;i<N;i++)
	for(j=0;j<M;j++)
		S[i][j]=A[i][j] + MAX(S[i-1][j] if(i>0), S[i][j-1] if(j>0), 0)

max = S[i-1][j-1]

````


####关于动态规划

Dynamic Programming 动态规划，这个名字听起来很不容易理解，实际他可能表达的是，当前这一步（当前状态）的计算，是要动态的直接或者间接的根据前面已经算出结果得出的，这里就一个名词叫做*无后效性*，意思是当前这一步的计算是和他前面有关系的，和他后面没有计算的没有关系，Fibonacci数列就是这样的，当前这一步的计算记过只和他前面两项的计算结果有关。

还有就是*最优结构*，最长上升子序列（LCS），最长公告子序列，都带一个最字，也就是说，要求的结果就是一个最优的结果

*存储，重复计算*

在动态规划的过程，常常就是存储计算过的值，避免重复计算，比如在Fibonacci数列中，要计算第N个需要求出N-1和N-2，但是还需要把N-1和N-2分别求出来吗，如果分别求出来就相当于重复计算了一次N-3前面所有的值，当然这还是一个地柜的过程，每个值都会被重复计算，其实这都是不需要的，计算过可以存储起来，再次需要就不用计算了。对于Fibonacci，只需要当前计算的前两个值，所以只需要两个变量来存储前两个值就可以了。


###REFERENCE

- [Dynamic Programming – From Novice to Advanced](https://www.topcoder.com/community/data-science/data-science-tutorials/dynamic-programming-from-novice-to-advanced/)
- [什么是动态规划？动态规划的意义是什么？](https://www.zhihu.com/question/23995189)